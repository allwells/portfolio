{"ast":null,"code":"import _slicedToArray from \"/home/allie/Project/client-thecurrent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction round(number) {\n  var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.pow(10, digits);\n  return Math.round(base * number) / base;\n}\n\nfunction hslaToHsva(_ref) {\n  var h = _ref.h,\n      s = _ref.s,\n      l = _ref.l,\n      a = _ref.a;\n  var ss = s * ((l < 50 ? l : 100 - l) / 100);\n  return {\n    h: h,\n    s: ss > 0 ? 2 * ss / (l + ss) * 100 : 0,\n    v: l + ss,\n    a: a\n  };\n}\n\nvar angleUnits = {\n  grad: 360 / 400,\n  turn: 360,\n  rad: 360 / (Math.PI * 2)\n};\n\nfunction parseHue(value) {\n  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"deg\";\n  return Number(value) * (angleUnits[unit] || 1);\n}\n\nvar HSL_REGEXP = /hsla?\\(?\\s*(-?\\d*\\.?\\d+)(deg|rad|grad|turn)?[,\\s]+(-?\\d*\\.?\\d+)%?[,\\s]+(-?\\d*\\.?\\d+)%?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n\nfunction parseHsla(color) {\n  var match = HSL_REGEXP.exec(color);\n\n  if (!match) {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n\n  return hslaToHsva({\n    h: parseHue(match[1], match[2]),\n    s: Number(match[3]),\n    l: Number(match[4]),\n    a: match[5] === void 0 ? 1 : Number(match[5]) / (match[6] ? 100 : 1)\n  });\n}\n\nfunction rgbaToHsva(_ref2) {\n  var r = _ref2.r,\n      g = _ref2.g,\n      b = _ref2.b,\n      a = _ref2.a;\n  var max = Math.max(r, g, b);\n  var delta = max - Math.min(r, g, b);\n  var hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;\n  return {\n    h: round(60 * (hh < 0 ? hh + 6 : hh)),\n    s: round(max ? delta / max * 100 : 0),\n    v: round(max / 255 * 100),\n    a: a\n  };\n}\n\nfunction parseHex(color) {\n  var hex = color[0] === \"#\" ? color.slice(1) : color;\n\n  if (hex.length === 3) {\n    return rgbaToHsva({\n      r: parseInt(hex[0] + hex[0], 16),\n      g: parseInt(hex[1] + hex[1], 16),\n      b: parseInt(hex[2] + hex[2], 16),\n      a: 1\n    });\n  }\n\n  return rgbaToHsva({\n    r: parseInt(hex.slice(0, 2), 16),\n    g: parseInt(hex.slice(2, 4), 16),\n    b: parseInt(hex.slice(4, 6), 16),\n    a: 1\n  });\n}\n\nvar RGB_REGEXP = /rgba?\\(?\\s*(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?[,\\s]+(-?\\d*\\.?\\d+)(%)?,?\\s*[/\\s]*(-?\\d*\\.?\\d+)?(%)?\\s*\\)?/i;\n\nfunction parseRgba(color) {\n  var match = RGB_REGEXP.exec(color);\n\n  if (!match) {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n\n  return rgbaToHsva({\n    r: Number(match[1]) / (match[2] ? 100 / 255 : 1),\n    g: Number(match[3]) / (match[4] ? 100 / 255 : 1),\n    b: Number(match[5]) / (match[6] ? 100 / 255 : 1),\n    a: match[7] === void 0 ? 1 : Number(match[7]) / (match[8] ? 100 : 1)\n  });\n}\n\nvar VALIDATION_REGEXP = {\n  hex: /^#?([0-9A-F]{3}){1,2}$/i,\n  rgb: /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  rgba: /^rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/i,\n  hsl: /hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\s*,\\s*(\\d+(?:\\.\\d+)?%)\\)/i,\n  hsla: /^hsla\\((\\d+),\\s*([\\d.]+)%,\\s*([\\d.]+)%,\\s*(\\d*(?:\\.\\d+)?)\\)$/i\n};\nvar CONVERTERS = {\n  hex: parseHex,\n  rgb: parseRgba,\n  rgba: parseRgba,\n  hsl: parseHsla,\n  hsla: parseHsla\n};\n\nfunction isColorValid(color) {\n  for (var _i = 0, _Object$entries = Object.entries(VALIDATION_REGEXP); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        regexp = _Object$entries$_i[1];\n\n    if (regexp.test(color)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction parseColor(color) {\n  if (typeof color !== \"string\") {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n  }\n\n  if (color === \"transparent\") {\n    return {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 0\n    };\n  }\n\n  var trimmed = color.trim();\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(VALIDATION_REGEXP); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        rule = _Object$entries2$_i[0],\n        regexp = _Object$entries2$_i[1];\n\n    if (regexp.test(trimmed)) {\n      return CONVERTERS[rule](trimmed);\n    }\n  }\n\n  return {\n    h: 0,\n    s: 0,\n    v: 0,\n    a: 1\n  };\n}\n\nexport { isColorValid, parseColor, parseHex, parseHsla, parseHue, parseRgba, round };","map":null,"metadata":{},"sourceType":"module"}